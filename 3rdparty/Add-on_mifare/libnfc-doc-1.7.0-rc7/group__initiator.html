<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libnfc: NFC initiator</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libnfc
   &#160;<span id="projectnumber">1.7.0-rc7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NFC initiator</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#ga4cab5665c89d5be858147b1548c7af3f">nfc_initiator_init</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize NFC device as initiator (reader)  <a href="#ga4cab5665c89d5be858147b1548c7af3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#ga68ff1cacb14696dfe16e892499b24bc3">nfc_initiator_init_secure_element</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize NFC device as initiator with its secure element initiator (reader)  <a href="#ga68ff1cacb14696dfe16e892499b24bc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gacbe0fa197206cac99c83ed0152174811">nfc_initiator_select_passive_target</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="structnfc__modulation.html">nfc_modulation</a> nm, const uint8_t *pbtInitData, const size_t szInitData, <a class="el" href="structnfc__target.html">nfc_target</a> *pnt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a passive or emulated tag.  <a href="#gacbe0fa197206cac99c83ed0152174811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gab0f9be52687bf9d62ba75abaf62a4c2c">nfc_initiator_list_passive_targets</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="structnfc__modulation.html">nfc_modulation</a> nm, <a class="el" href="structnfc__target.html">nfc_target</a> ant[], const size_t szTargets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">List passive or emulated tags.  <a href="#gab0f9be52687bf9d62ba75abaf62a4c2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gaed2949299759f9a889f6c93f5c365296">nfc_initiator_poll_target</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="structnfc__modulation.html">nfc_modulation</a> *pnmModulations, const size_t szModulations, const uint8_t uiPollNr, const uint8_t uiPeriod, <a class="el" href="structnfc__target.html">nfc_target</a> *pnt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polling for NFC targets.  <a href="#gaed2949299759f9a889f6c93f5c365296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gac47b117248c72b1e746ab9424e89c5b4">nfc_initiator_select_dep_target</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="nfc-types_8h.html#a49938f9d4ecf6ba10554cbab30751b44">nfc_dep_mode</a> ndm, const <a class="el" href="nfc-types_8h.html#aea4162a0fc281cafaf9905ae8efe8fe3">nfc_baud_rate</a> nbr, const <a class="el" href="structnfc__dep__info.html">nfc_dep_info</a> *pndiInitiator, <a class="el" href="structnfc__target.html">nfc_target</a> *pnt, const int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a target and request active or passive mode for D.E.P. (Data Exchange Protocol)  <a href="#gac47b117248c72b1e746ab9424e89c5b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gaa5e08a085fc83e21714ffad598c1b89e">nfc_initiator_poll_dep_target</a> (struct <a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="nfc-types_8h.html#a49938f9d4ecf6ba10554cbab30751b44">nfc_dep_mode</a> ndm, const <a class="el" href="nfc-types_8h.html#aea4162a0fc281cafaf9905ae8efe8fe3">nfc_baud_rate</a> nbr, const <a class="el" href="structnfc__dep__info.html">nfc_dep_info</a> *pndiInitiator, <a class="el" href="structnfc__target.html">nfc_target</a> *pnt, const int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll a target and request active or passive mode for D.E.P. (Data Exchange Protocol)  <a href="#gaa5e08a085fc83e21714ffad598c1b89e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#ga13ee4cff7a632065c0489d89e98ab41b">nfc_initiator_transceive_bytes</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to target then retrieve data from target.  <a href="#ga13ee4cff7a632065c0489d89e98ab41b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#ga16da6debcdd406542916fff1fafbff59">nfc_initiator_transceive_bits</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transceive raw bit-frames to a target.  <a href="#ga16da6debcdd406542916fff1fafbff59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gaa62d32c4463b83e76b33a6995332d20f">nfc_initiator_transceive_bytes_timed</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, uint32_t *cycles)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to target then retrieve data from target.  <a href="#gaa62d32c4463b83e76b33a6995332d20f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#gaaa5252f8eb1deaf688e6cd1fad9bdc45">nfc_initiator_target_is_present</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const <a class="el" href="structnfc__target.html">nfc_target</a> *pnt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check target presence.  <a href="#gaaa5252f8eb1deaf688e6cd1fad9bdc45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__initiator.html#ga1b82168a15baa41b7050fb6200f01791">nfc_initiator_transceive_bits_timed</a> (<a class="el" href="structnfc__device.html">nfc_device</a> *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar, uint32_t *cycles)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transceive raw bit-frames to a target.  <a href="#ga1b82168a15baa41b7050fb6200f01791"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This page details how to act as "reader". </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga4cab5665c89d5be858147b1548c7af3f"></a><!-- doxytag: member="nfc.c::nfc_initiator_init" ref="ga4cab5665c89d5be858147b1548c7af3f" args="(nfc_device *pnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#ga4cab5665c89d5be858147b1548c7af3f">nfc_initiator_init</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize NFC device as initiator (reader) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, otherwise returns libnfc's error code (negative value) </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device is configured to function as RFID reader. After initialization it can be used to communicate to passive RFID tags and active NFC devices. The reader will act as initiator to communicate peer 2 peer (NFCIP) to other active NFC devices.</p>
<ul>
<li>Crc is handled by the device (NP_HANDLE_CRC = true)</li>
<li>Parity is handled the device (NP_HANDLE_PARITY = true)</li>
<li>Cryto1 cipher is disabled (NP_ACTIVATE_CRYPTO1 = false)</li>
<li>Easy framing is enabled (NP_EASY_FRAMING = true)</li>
<li>Auto-switching in ISO14443-4 mode is enabled (NP_AUTO_ISO14443_4 = true)</li>
<li>Invalid frames are not accepted (NP_ACCEPT_INVALID_FRAMES = false)</li>
<li>Multiple frames are not accepted (NP_ACCEPT_MULTIPLE_FRAMES = false)</li>
<li>14443-A mode is activated (NP_FORCE_ISO14443_A = true)</li>
<li>speed is set to 106 kbps (NP_FORCE_SPEED_106 = true)</li>
<li>Let the device try forever to find a target (NP_INFINITE_SELECT = true)</li>
<li>RF field is shortly dropped (if it was enabled) then activated again </li>
</ul>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00443">443</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga68ff1cacb14696dfe16e892499b24bc3"></a><!-- doxytag: member="nfc.c::nfc_initiator_init_secure_element" ref="ga68ff1cacb14696dfe16e892499b24bc3" args="(nfc_device *pnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#ga68ff1cacb14696dfe16e892499b24bc3">nfc_initiator_init_secure_element</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize NFC device as initiator with its secure element initiator (reader) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, otherwise returns libnfc's error code (negative value) </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device is configured to function as secure element reader. After initialization it can be used to communicate with the secure element. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>RF field is desactvated in order to some power </dd></dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00483">483</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab0f9be52687bf9d62ba75abaf62a4c2c"></a><!-- doxytag: member="nfc.c::nfc_initiator_list_passive_targets" ref="gab0f9be52687bf9d62ba75abaf62a4c2c" args="(nfc_device *pnd, const nfc_modulation nm, nfc_target ant[], const size_t szTargets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gab0f9be52687bf9d62ba75abaf62a4c2c">nfc_initiator_list_passive_targets</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__modulation.html">nfc_modulation</a>&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnfc__target.html">nfc_target</a>&#160;</td>
          <td class="paramname"><em>ant</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szTargets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List passive or emulated tags. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of targets found on success, otherwise returns libnfc's error code (negative value)</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nm</td><td>desired modulation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ant</td><td>array of <em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> that will be filled with targets info </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szTargets</td><td>size of <em>ant</em> (will be the max targets listed)</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device will try to find the available passive tags. Some NFC devices are capable to emulate passive tags. The standards (ISO18092 and ECMA-340) describe the modulation that can be used for reader to passive communications. The chip needs to know with what kind of tag it is dealing with, therefore the initial modulation and speed (106, 212 or 424 kbps) should be supplied. </p>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00554">554</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5e08a085fc83e21714ffad598c1b89e"></a><!-- doxytag: member="nfc.c::nfc_initiator_poll_dep_target" ref="gaa5e08a085fc83e21714ffad598c1b89e" args="(struct nfc_device *pnd, const nfc_dep_mode ndm, const nfc_baud_rate nbr, const nfc_dep_info *pndiInitiator, nfc_target *pnt, const int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gaa5e08a085fc83e21714ffad598c1b89e">nfc_initiator_poll_dep_target</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="nfc-types_8h.html#a49938f9d4ecf6ba10554cbab30751b44">nfc_dep_mode</a>&#160;</td>
          <td class="paramname"><em>ndm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="nfc-types_8h.html#aea4162a0fc281cafaf9905ae8efe8fe3">nfc_baud_rate</a>&#160;</td>
          <td class="paramname"><em>nbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__dep__info.html">nfc_dep_info</a> *&#160;</td>
          <td class="paramname"><em>pndiInitiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnfc__target.html">nfc_target</a> *&#160;</td>
          <td class="paramname"><em>pnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Poll a target and request active or passive mode for D.E.P. (Data Exchange Protocol) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns selected D.E.P targets count on success, otherwise returns libnfc's error code (negative value).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ndm</td><td>desired D.E.P. mode (<em>NDM_ACTIVE</em> or <em>NDM_PASSIVE</em> for active, respectively passive mode) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nbr</td><td>desired baud rate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ndiInitiator</td><td>pointer <em><a class="el" href="structnfc__dep__info.html" title="NFC target information in D.E.P. (Data Exchange Protocol) see ISO/IEC 18092 (NFCIP-1)">nfc_dep_info</a></em> struct that contains <em>NFCID3</em> and <em>General</em> <em>Bytes</em> to set to the initiator device (optionnal, can be <em>NULL</em>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnt</td><td>is a <em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> struct pointer where target information will be put. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device will try to find an available D.E.P. target. The standards (ISO18092 and ECMA-340) describe the modulation that can be used for reader to passive communications.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><em><a class="el" href="structnfc__dep__info.html" title="NFC target information in D.E.P. (Data Exchange Protocol) see ISO/IEC 18092 (NFCIP-1)">nfc_dep_info</a></em> will be returned when the target was acquired successfully. </dd></dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00669">669</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaed2949299759f9a889f6c93f5c365296"></a><!-- doxytag: member="nfc.c::nfc_initiator_poll_target" ref="gaed2949299759f9a889f6c93f5c365296" args="(nfc_device *pnd, const nfc_modulation *pnmModulations, const size_t szModulations, const uint8_t uiPollNr, const uint8_t uiPeriod, nfc_target *pnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gaed2949299759f9a889f6c93f5c365296">nfc_initiator_poll_target</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__modulation.html">nfc_modulation</a> *&#160;</td>
          <td class="paramname"><em>pnmModulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szModulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>uiPollNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>uiPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnfc__target.html">nfc_target</a> *&#160;</td>
          <td class="paramname"><em>pnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polling for NFC targets. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns polled targets count, otherwise returns libnfc's error code (negative value).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device </td></tr>
    <tr><td class="paramname">pnmModulations</td><td>desired modulations </td></tr>
    <tr><td class="paramname">szModulations</td><td>size of <em>pnmModulations</em> </td></tr>
    <tr><td class="paramname">uiPollNr</td><td>specifies the number of polling (0x01 – 0xFE: 1 up to 254 polling, 0xFF: Endless polling) </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>one polling is a polling for each desired target type </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uiPeriod</td><td>indicates the polling period in units of 150 ms (0x01 – 0x0F: 150ms – 2.25s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>e.g. if uiPeriod=10, it will poll each desired target type during 1.5s </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pnt</td><td>pointer on <em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> (over)writable struct </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00614">614</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac47b117248c72b1e746ab9424e89c5b4"></a><!-- doxytag: member="nfc.c::nfc_initiator_select_dep_target" ref="gac47b117248c72b1e746ab9424e89c5b4" args="(nfc_device *pnd, const nfc_dep_mode ndm, const nfc_baud_rate nbr, const nfc_dep_info *pndiInitiator, nfc_target *pnt, const int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gac47b117248c72b1e746ab9424e89c5b4">nfc_initiator_select_dep_target</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="nfc-types_8h.html#a49938f9d4ecf6ba10554cbab30751b44">nfc_dep_mode</a>&#160;</td>
          <td class="paramname"><em>ndm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="nfc-types_8h.html#aea4162a0fc281cafaf9905ae8efe8fe3">nfc_baud_rate</a>&#160;</td>
          <td class="paramname"><em>nbr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__dep__info.html">nfc_dep_info</a> *&#160;</td>
          <td class="paramname"><em>pndiInitiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnfc__target.html">nfc_target</a> *&#160;</td>
          <td class="paramname"><em>pnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select a target and request active or passive mode for D.E.P. (Data Exchange Protocol) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns selected D.E.P targets count on success, otherwise returns libnfc's error code (negative value).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ndm</td><td>desired D.E.P. mode (<em>NDM_ACTIVE</em> or <em>NDM_PASSIVE</em> for active, respectively passive mode) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nbr</td><td>desired baud rate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ndiInitiator</td><td>pointer <em><a class="el" href="structnfc__dep__info.html" title="NFC target information in D.E.P. (Data Exchange Protocol) see ISO/IEC 18092 (NFCIP-1)">nfc_dep_info</a></em> struct that contains <em>NFCID3</em> and <em>General</em> <em>Bytes</em> to set to the initiator device (optionnal, can be <em>NULL</em>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnt</td><td>is a <em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> struct pointer where target information will be put. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device will try to find an available D.E.P. target. The standards (ISO18092 and ECMA-340) describe the modulation that can be used for reader to passive communications.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><em><a class="el" href="structnfc__dep__info.html" title="NFC target information in D.E.P. (Data Exchange Protocol) see ISO/IEC 18092 (NFCIP-1)">nfc_dep_info</a></em> will be returned when the target was acquired successfully.</dd></dl>
<p>If timeout equals to 0, the function blocks indefinitely (until an error is raised or function is completed) If timeout equals to -1, the default timeout will be used </p>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00644">644</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacbe0fa197206cac99c83ed0152174811"></a><!-- doxytag: member="nfc.c::nfc_initiator_select_passive_target" ref="gacbe0fa197206cac99c83ed0152174811" args="(nfc_device *pnd, const nfc_modulation nm, const uint8_t *pbtInitData, const size_t szInitData, nfc_target *pnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gacbe0fa197206cac99c83ed0152174811">nfc_initiator_select_passive_target</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__modulation.html">nfc_modulation</a>&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtInitData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szInitData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnfc__target.html">nfc_target</a> *&#160;</td>
          <td class="paramname"><em>pnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select a passive or emulated tag. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns selected passive target count on success, otherwise returns libnfc's error code (negative value)</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represent currently used device </td></tr>
    <tr><td class="paramname">nm</td><td>desired modulation </td></tr>
    <tr><td class="paramname">pbtInitData</td><td>optional initiator data used for Felica, ISO14443B, Topaz polling or to select a specific UID in ISO14443A. </td></tr>
    <tr><td class="paramname">szInitData</td><td>length of initiator data <em>pbtInitData</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>pbtInitData is used with different kind of data depending on modulation type:<ul>
<li>for an ISO/IEC 14443 type A modulation, pbbInitData contains the UID you want to select;</li>
<li>for an ISO/IEC 14443 type B modulation, pbbInitData contains Application Family Identifier (AFI) (see ISO/IEC 14443-3);</li>
<li>for a FeliCa modulation, pbbInitData contains polling payload (see ISO/IEC 18092 11.2.2.5).</li>
</ul>
</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pnt</td><td><em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> struct pointer which will filled if available</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device will try to find one available passive tag or emulated tag.</p>
<p>The chip needs to know with what kind of tag it is dealing with, therefore the initial modulation and speed (106, 212 or 424 kbps) should be supplied. </p>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00509">509</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa5252f8eb1deaf688e6cd1fad9bdc45"></a><!-- doxytag: member="nfc.c::nfc_initiator_target_is_present" ref="gaaa5252f8eb1deaf688e6cd1fad9bdc45" args="(nfc_device *pnd, const nfc_target *pnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gaaa5252f8eb1deaf688e6cd1fad9bdc45">nfc_initiator_target_is_present</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnfc__target.html">nfc_target</a> *&#160;</td>
          <td class="paramname"><em>pnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check target presence. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 on success, otherwise returns libnfc's error code.</dd></dl>
<p>This function tests if <em><a class="el" href="structnfc__target.html" title="NFC target structure.">nfc_target</a></em> is currently present on NFC device. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The target have to be selected before check its presence </dd>
<dd>
To run the test, one or more commands will be sent to target </dd></dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00835">835</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga16da6debcdd406542916fff1fafbff59"></a><!-- doxytag: member="nfc.c::nfc_initiator_transceive_bits" ref="ga16da6debcdd406542916fff1fafbff59" args="(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#ga16da6debcdd406542916fff1fafbff59">nfc_initiator_transceive_bits</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szTxBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTxPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRxPar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transceive raw bit-frames to a target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns received bits count on success, otherwise returns libnfc's error code</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represents currently used device </td></tr>
    <tr><td class="paramname">pbtTx</td><td>contains a byte array of the frame that needs to be transmitted. </td></tr>
    <tr><td class="paramname">szTxBits</td><td>contains the length in bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>For example the REQA (0x26) command (first anti-collision command of ISO14443-A) must be precise 7 bits long. This is not possible by using <a class="el" href="group__initiator.html#ga13ee4cff7a632065c0489d89e98ab41b" title="Send data to target then retrieve data from target.">nfc_initiator_transceive_bytes()</a>. With that function you can only communicate frames that consist of full bytes. When you send a full byte (8 bits + 1 parity) with the value of REQA (0x26), a tag will simply not respond. More information about this can be found in the anti-collision example (<em>nfc-anticol</em>).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pbtTxPar</td><td>parameter contains a byte array of the corresponding parity bits needed to send per byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>For example if you send the SELECT_ALL (0x93, 0x20) = [ 10010011, 00100000 ] command, you have to supply the following parity bytes (0x01, 0x00) to define the correct odd parity bits. This is only an example to explain how it works, if you just are sending two bytes with ISO14443-A compliant parity bits you better can use the <a class="el" href="group__initiator.html#ga13ee4cff7a632065c0489d89e98ab41b" title="Send data to target then retrieve data from target.">nfc_initiator_transceive_bytes()</a> function.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pbtRx</td><td>response from the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szRx</td><td>size of <em>pbtRx</em> (Will return NFC_EOVFLOW if RX exceeds this size) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbtRxPar</td><td>parameter contains a byte array of the corresponding parity bits</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device (configured as <em>initiator</em>) will transmit low-level messages where only the modulation is handled by the <em>PN53x</em> chip. Construction of the frame (data, CRC and parity) is completely done by libnfc. This can be very useful for testing purposes. Some protocols (e.g. MIFARE Classic) require to violate the ISO14443-A standard by sending incorrect parity and CRC bytes. Using this feature you are able to simulate these frames. </p>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00782">782</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b82168a15baa41b7050fb6200f01791"></a><!-- doxytag: member="nfc.c::nfc_initiator_transceive_bits_timed" ref="ga1b82168a15baa41b7050fb6200f01791" args="(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTxBits, const uint8_t *pbtTxPar, uint8_t *pbtRx, const size_t szRx, uint8_t *pbtRxPar, uint32_t *cycles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#ga1b82168a15baa41b7050fb6200f01791">nfc_initiator_transceive_bits_timed</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szTxBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTxPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRxPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transceive raw bit-frames to a target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns received bits count on success, otherwise returns libnfc's error code</dd></dl>
<p>This function is similar to <a class="el" href="group__initiator.html#ga16da6debcdd406542916fff1fafbff59" title="Transceive raw bit-frames to a target.">nfc_initiator_transceive_bits()</a> with the following differences:</p>
<ul>
<li>A precise cycles counter will indicate the number of cycles between emission &amp; reception of frames.</li>
<li>It only supports mode with <em>NP_EASY_FRAMING</em> option disabled and CRC must be handled manually.</li>
<li>Overall communication with the host is heavier and slower.</li>
</ul>
<p>Timer control: By default timer configuration tries to maximize the precision, which also limits the maximum cycles count before saturation/timeout. E.g. with PN53x it can count up to 65535 cycles, so about 4.8ms, with a precision of about 73ns.</p>
<ul>
<li>If you're ok with the defaults, set *cycles = 0 before calling this function.</li>
<li>If you need to count more cycles, set *cycles to the maximum you expect but don't forget you'll loose in precision and it'll take more time before timeout, so don't abuse!</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The configuration option <em>NP_EASY_FRAMING</em> must be set to <code>false</code>. </dd>
<dd>
The configuration option <em>NP_HANDLE_CRC</em> must be set to <code>false</code>. </dd>
<dd>
The configuration option <em>NP_HANDLE_PARITY</em> must be set to <code>true</code> (the default value). </dd></dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00862">862</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga13ee4cff7a632065c0489d89e98ab41b"></a><!-- doxytag: member="nfc.c::nfc_initiator_transceive_bytes" ref="ga13ee4cff7a632065c0489d89e98ab41b" args="(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#ga13ee4cff7a632065c0489d89e98ab41b">nfc_initiator_transceive_bytes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to target then retrieve data from target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns received bytes count on success, otherwise returns libnfc's error code</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represents currently used device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pbtTx</td><td>contains a byte array of the frame that needs to be transmitted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szTx</td><td>contains the length in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbtRx</td><td>response from the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szRx</td><td>size of <em>pbtRx</em> (Will return NFC_EOVFLOW if RX exceeds this size) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<p>The NFC device (configured as initiator) will transmit the supplied bytes (<em>pbtTx</em>) to the target. It waits for the response and stores the received bytes in the <em>pbtRx</em> byte array.</p>
<p>If <em>NP_EASY_FRAMING</em> option is disabled the frames will sent and received in raw mode: <em>PN53x</em> will not handle input neither output data.</p>
<p>The parity bits are handled by the <em>PN53x</em> chip. The CRC can be generated automatically or handled manually. Using this function, frames can be communicated very fast via the NFC initiator to the tag.</p>
<p>Tests show that on average this way of communicating is much faster than using the regular driver/middle-ware (often supplied by manufacturers).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The configuration option <em>NP_HANDLE_PARITY</em> must be set to <code>true</code> (the default value).</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>When used with MIFARE Classic, NFC_EMFCAUTHFAIL error is returned if authentication command failed. You need to re-select the tag to operate with.</dd></dl>
<p>If timeout equals to 0, the function blocks indefinitely (until an error is raised or function is completed) If timeout equals to -1, the default timeout will be used </p>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00739">739</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa62d32c4463b83e76b33a6995332d20f"></a><!-- doxytag: member="nfc.c::nfc_initiator_transceive_bytes_timed" ref="gaa62d32c4463b83e76b33a6995332d20f" args="(nfc_device *pnd, const uint8_t *pbtTx, const size_t szTx, uint8_t *pbtRx, const size_t szRx, uint32_t *cycles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__initiator.html#gaa62d32c4463b83e76b33a6995332d20f">nfc_initiator_transceive_bytes_timed</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnfc__device.html">nfc_device</a> *&#160;</td>
          <td class="paramname"><em>pnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pbtTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbtRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>szRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data to target then retrieve data from target. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns received bytes count on success, otherwise returns libnfc's error code.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pnd</td><td><em><a class="el" href="structnfc__device.html" title="NFC device information.">nfc_device</a></em> struct pointer that represents currently used device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pbtTx</td><td>contains a byte array of the frame that needs to be transmitted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szTx</td><td>contains the length in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbtRx</td><td>response from the target </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">szRx</td><td>size of <em>pbtRx</em> (Will return NFC_EOVFLOW if RX exceeds this size)</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="group__initiator.html#ga13ee4cff7a632065c0489d89e98ab41b" title="Send data to target then retrieve data from target.">nfc_initiator_transceive_bytes()</a> with the following differences:</p>
<ul>
<li>A precise cycles counter will indicate the number of cycles between emission &amp; reception of frames.</li>
<li>It only supports mode with <em>NP_EASY_FRAMING</em> option disabled.</li>
<li>Overall communication with the host is heavier and slower.</li>
</ul>
<p>Timer control: By default timer configuration tries to maximize the precision, which also limits the maximum cycles count before saturation/timeout. E.g. with PN53x it can count up to 65535 cycles, so about 4.8ms, with a precision of about 73ns.</p>
<ul>
<li>If you're ok with the defaults, set *cycles = 0 before calling this function.</li>
<li>If you need to count more cycles, set *cycles to the maximum you expect but don't forget you'll loose in precision and it'll take more time before timeout, so don't abuse!</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The configuration option <em>NP_EASY_FRAMING</em> must be set to <code>false</code>. </dd>
<dd>
The configuration option <em>NP_HANDLE_PARITY</em> must be set to <code>true</code> (the default value). </dd></dl>

<p>Definition at line <a class="el" href="nfc_8c_source.html#l00818">818</a> of file <a class="el" href="nfc_8c_source.html">nfc.c</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 5 2013 16:09:20 for libnfc by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
